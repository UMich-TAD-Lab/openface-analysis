---
title: "OpenFaceAnalysis"
author: "Julianna Calabrese"
date: "12/12/2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
#install.packages("mosaic")
#install.packages("ggplot2")
#install.packages("tidyr")
#install.packages("dplyr")
#install.packages("psych")
#install.packages("nlme")
#install.packages("plyr")
#install.packages("Hmisc")
#install.packages("rmarkdown")
#install.packages("shiny")
#install.packages("yaml")
#install.packages("rapportools")
#install.packages("lavaan")
#install.packages("lme4")
#install.packages("corrr")
#install.packages("corrplot")
#install.packages("reshape2")

library(mosaic)
library(ggplot2)
library(tidyr)
library(dplyr)
library(psych)
library(nlme)
library(plyr)
library(Hmisc)
library(rmarkdown)
library(shiny)
library(yaml)
library(rapportools)
library(lavaan)
library(lme4)
library(corrr)
library(corrplot)
library(reshape2)
```

### Outline/Description

This file will be where all the primary data analysis occurs. First, in a totally separate .rmd file, you'll want to convert cp_whatever to a "long" format, meaning that every time for cortisol will have its own row. This long dataset will also have to include everything else too: gender/demographic data, AUs, CTQ, etc.

Then, you're going to run a model that looks like this...

mod1 <- lm(cortisol~time+time^2+sex+AU1+AU1*time+AU1*time*time^2)

...but it's not going to be a lm() model, it's going to be a multilevel growth curve model, so you'll probably need to use the lme4() package with the lmer() command. This will produce a fixed effects table that represents the parameters of everything that you put in the above model to predict cortisol. Then you need to tell R what your random effects are, which is the intercept and time. 

Then you do something with landmark registration, but that's kind of already done, so you need to ask someone who ask access to that dataset to share it with you.

All the instructions can be found in Lopez-Duran 2014. Do NOT do anything involving AUC!

## Load in data and other logistics

```{r}
cp_long <- read.csv(file="C:/Users/jrcala/Documents/My Research/RStudio/cp_long.csv", header=TRUE, sep=",")
#cp_long <- read.csv(file="/Users/Julianna/Desktop/data/cp_long.csv", header=TRUE, sep=",")
cp_long$X <- NULL
```

## Pre-Analysis Cleaning

```{r}
cp_long$ctqsum <- cp_long$CTQ_Total_Sum
cp_long$emosum <- cp_long$CTQ_EmoAbuse_Sum

cp_long$CTQ_Total_Sum <- NULL
cp_long$CTQ_Total_Mean <- NULL
cp_long$CTQ_EmoAbuse_Sum <- NULL
cp_long$CTQ_EmoAbuse_Mean <- NULL
cp_long$CTQ_PhyAbuse_Sum <- NULL
cp_long$CTQ_PhyAbuse_Mean <- NULL
cp_long$CTQ_SexAbuse_Sum <- NULL
cp_long$CTQ_SexAbuse_Mean <- NULL
```

## Centering

```{r}
hist(cp_long$pain) #Wow, that's terrible
cp_long$painC <- scale(cp_long$pain)
hist(cp_long$painC) #Slightly better, there's an outlier though

hist(cp_long$anger)
cp_long$angerC <- scale(cp_long$anger)
hist(cp_long$angerC)

hist(cp_long$fear)
cp_long$fearC <- scale(cp_long$fear)
hist(cp_long$fear)

hist(cp_long$happiness)
cp_long$happinessC <- scale(cp_long$happiness)
hist(cp_long$happinessC)

hist(cp_long$peaktimenum)
cp_long$peaktimenumC <- scale(cp_long$peaktimenum)
hist(cp_long$peaktimenumC)

hist(cp_long$cortvalue)
cp_long$cortvalueC <- scale(cp_long$cortvalue)
hist(cp_long$cortvalueC)

hist(cp_long$stime) #That looks fine
cp_long$stimeC <- scale(cp_long$stime)
hist(cp_long$stimeC) #It almost looks worse in a way, maybe I won't use it

hist(cp_long$ctqsum)
cp_long$ctqsumC <- scale(cp_long$ctqsum)
hist(cp_long$ctqsumC)

hist(cp_long$emosum)
cp_long$emosumC <- scale(cp_long$emosum)
hist(cp_long$emosumC)

#This is timenum's version of centering
cp_long$timenumC <- 0
cp_long$timenumC[cp_long$timenum==4] <- 1
cp_long$timenumC[cp_long$timenum==5] <- 2
cp_long$timenumC[cp_long$timenum==6] <- 3
cp_long$timenumC[cp_long$timenum==7] <- 4
cp_long$timenumC[cp_long$timenum==8] <- 5
cp_long$timenumC[cp_long$timenum==9] <- 6
cp_long$timenumC[cp_long$timenum==10] <- 7
cp_long$timenumC[cp_long$timenum==11] <- 8
cp_long$timenumC[cp_long$timenum==12] <- 9

cp_long$timenum <- as.factor(cp_long$timenum)
cp_long$timenumC <- as.factor(cp_long$timenumC)
```

## Creating variables: maxtime, timetopeak, timebeforepeak, timeafterpeak

```{r}
cp_long$maxtime <- 0
cp_long$maxtime <- ave(cp_long$stimeC, cp_long$id, FUN = max)
hist(cp_long$maxtime)

cp_long$timetopeak <- 0
cp_long$timetopeak <- (cp_long$peaktimenumC - cp_long$maxtime) * -1
hist(cp_long$timetopeak)

cp_long$timebeforepeak <- 0
cp_long$timebeforepeak <- ifelse(cp_long$timetopeak < 0, cp_long$timetopeak, 0)
#If timetopeak < 0, then timebeforepeak = timetopeak
#If timetopeak > 0, then timebeforepeak = 0
hist(cp_long$timebeforepeak)

cp_long$timeafterpeak <- 0
cp_long$timeafterpeak <- ifelse(cp_long$timetopeak > 0, cp_long$timetopeak, 0)
#If timetopeak > 0, then timeafterpeak = timetopeak
#If timetopeak < 0, then timeafterpeak = 0
hist(cp_long$timeafterpeak)
```

## Creating variables: maxgrouptime, timebeforegrouppeak, timeaftergrouppeak

```{r}
#Uhhhh... I'll do that later. I'm not 100% sure what I should use as the "group" anyway. 
#Maybe I don't even need to do this step. 
```

## Replicating that plot from Lopez-Duran 2014

```{r}
test.plot <- aggregate( cortvalue ~ timenum, cp_long, mean )

plot(test.plot, col="black", lwd=2, type="o", xlab="Time", ylab="Cortisol", main="Cortisol Over Time")

ggplot(cp_long, aes(timenum, cortvalue, group=factor(id))) + geom_line(aes(color=factor(timenum))) + theme(legend.position = "none") + ggtitle("Cortisol Line Graph")

ggplot(cp_long, aes(timenum, cortvalue, group=factor(id))) + geom_jitter(aes(color=factor(timenum))) + theme(legend.position = "none") + ggtitle("Cortisol Dot Plot")
```

## Correlations

```{r}
matrix_vars <- c("cortvalue", "stime", "timenum", "pain", "gender", "ctqsum")

cp_matrix <- cp_long[matrix_vars]

matrix1 <- stats::cor(cp_matrix, use = "complete.obs")

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

corrplot(matrix1, method = "color", col = col(200),
         type = "upper", order = "hclust", number.cex = .7,
         addCoef.col = "black", # Add coefficient of correlation
         tl.col = "black", tl.srt = 90, # Text label color and rotation
         # Combine with significance
         #sig.level = 0.05, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag = FALSE)
```

## Basic lm() models

```{r}
mod1 <- lm(cortvalue ~ stime, data = cp_long)
summary(mod1) #sig

mod2 <- lm(cortvalue ~ ctqsum, data = cp_long)
summary(mod2) #sig

mod3 <- lm(cortvalue ~ pain, data = cp_long)
summary(mod3) #not sig

mod4 <- lm(cortvalue ~ gender, data = cp_long)
summary(mod4) #sig
```

Let's build a bigger lm() model.

```{r}
mod5 <- lm(cortvalue ~ stime + ctqsum + gender, data = cp_long)
summary(mod5)

mod5.2 <- lm(cortvalue ~ timenum + ctqsum + gender, data = cp_long)
summary(mod5.2)

mod6 <- lm(cortvalue ~ stime + ctqsum + gender + stime:ctqsum + stime:gender + ctqsum:gender + stime:ctqsum:gender, data = cp_long)
summary(mod6) #Jesus Christ
```

## Checking assumptions

```{r}
plot(mod5, which = 1) #Linearity - Good
plot(mod5, which = 2) #Normality - Bad but no registration
plot(mod5, which = 3) #Equality of variance - ???
plot(mod5, which = 4) #Leverage / Identifies outliers - 3 outliers
```

```{r}
plot(mod6, which = 1) #Linearity
plot(mod6, which = 2) #Normality
plot(mod6, which = 3) #Equality of variance
plot(mod6, which = 4) #Leverage / Identifies outliers
```

## Trying lmer() again

https://ourcodingclub.github.io/2017/03/15/mixed-models.html

1. Check distribution of explanatory variable(s).
2. Standardize explanatory variable(s).
3. Make basic lm() model.
4. Check assumptions for the basic lm() model.
5. Run more analyses if assumptions have been violated.
6. Modify the basic lm() model.
7. Fit your first lmer() model.
8. Check assumptions for the first lmer() model.
9. Crossed vs nested effects????
10. Make it all look pretty in tables and graphs.

## Testing out the big model with lm()

```{r}
bigmod <- lm(cortvalue~stime+stime^2+gender+painC+painC*stime+painC*stime*stime^2, data=cp_long)
summary(bigmod)
#This says that everything is significant: time, gender, pain, and interaction between time and pain except the Intercept.

bigmod2 <- lm(cortvalue~stimeC+stimeC^2+gender+painC+painC*stimeC+painC*stimeC*stimeC^2, data=cp_long)
summary(bigmod2)
#Okay, now pain isn't significant, huh. And now the intercept is significant. This is probably the correct model.
```

Your random effects are intercept and time.

Intercept estimate: -3.53375
stimeC estimate: -0.20656
painC estimate: 0.03253
gender estimate: 0.34327

## Checking distributions

```{r}
hist(cp_long$cortvalue)
hist(cp_long$stimeC)
hist(cp_long$painC)
```

## Basic lm() models

```{r}
basic1 <- lm(cortvalue ~ stimeC, data = cp_long)
summary(basic1) #Intercept and stimeC are significant

basic2 <- lm(cortvalue ~ gender, data = cp_long)
summary(basic2) #Intercept and gender are significant

basic3 <- lm(cortvalue ~ painC, data = cp_long)
summary(basic3) #Intercept is significant but painC is not

basic4 <- lm(cortvalue ~ ctqsumC, data = cp_long)
summary(basic4) #Intercept and CTQ are significant

basictest <- lm(cortvalue ~ timenumC, data = cp_long)
summary(basictest)
```

## Modified lm() models

```{r}
modified1 <- lm(cortvalue ~ stimeC + gender, data = cp_long)
summary(modified1) #All are significant

modified2 <- lm(cortvalue ~ stimeC + painC, data = cp_long)
summary(modified2) #Only Intercept and stimeC are significant

modified3 <- lm(cortvalue ~ stimeC + painC + gender, data = cp_long)
summary(modified3) #Intercept, stimeC, and gender are significant

modified4 <- lm(cortvalue ~ stimeC + ctqsumC + gender, data = cp_long)
summary(modified4) #All are significant

modified5 <- lm(cortvalue ~ timenum + ctqsumC + gender, data = cp_long)
summary(modified5) #All are significant
```

## lmer() model

```{r}
#mixed.lmer <- lmer(testScore ~ bodyLength2 + (1|mountainRange), data = dragons)
#summary(mixed.lmer)
#mountainRange is the random effect, bodyLength2 is fixed
#See that fun little 1? That's the intercept!

#Mixed effects models are supposed to have categorical variables... (and gender doesn't count here!)

lmer1 <- lmer(cortvalue ~ painC + gender + (1|stime), data = cp_long)
summary(lmer1)

lmer2 <- lmer(cortvalue ~ painC + gender + (1|timenum), data = cp_long)
summary(lmer2)

lmer3 <- lmer(cortvalue ~ painC + ctqsumC + gender + (1|stime), data = cp_long)
summary(lmer3)

lmer4 <- lmer(cortvalue ~ painC + ctqsumC + gender + (1|timenum), data = cp_long)
summary(lmer4)

lmertest <- lmer(cortvalue ~ gender+ (1|timenum), data = cp_long)
summary(lmertest)

goodmod <- lmer(cortvalue ~ painC + gender + ctqsumC + (1|stimeC), data = cp_long)
summary(goodmod)

goodmod2 <- lmer(cortvalue ~ painC + gender + ctqsumC + (1|timenumC), data = cp_long)
summary(goodmod2)
```

Let's see if either of those lmer() models worked. Probably not.

```{r}
plot(lmer1)
plot(lmer2)
plot(lmer3)
plot(lmer4)
plot(lmertest)
plot(goodmod)
```

```{r}
qqnorm(resid(lmer1)) + qqline(resid(lmer1)) #Bad
qqnorm(resid(lmer2)) + qqline(resid(lmer2)) #Bad
qqnorm(resid(lmer3)) + qqline(resid(lmer3)) #Bad
qqnorm(resid(lmer4)) + qqline(resid(lmer4)) #Bad
qqnorm(resid(lmertest)) + qqline(resid(lmertest)) #Bad
qqnorm(resid(goodmod)) + qqline(resid(goodmod)) #Bad
qqnorm(resid(goodmod2)) + qqline(resid(goodmod2)) #Bad
#I blame the lack of landmark registration at the moment
```

For "goodmod"...

stimeC variance: 0.04193
Residual variance: 1.02347
Total variance: 0.04193 + 1.02347 = 1.0654
Variance explained by stimeC = 0.04193/1.0654 = 0.03936
Cool... so stimeC explains 3% of the variance in goodmod. 
Same thing for timenumC (2.8%).

I think for lmer(), timenumC should be used anyway, since we shouldn't have a continous variable as a grouping variable.

