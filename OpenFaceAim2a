---
title: "OpenFaceAim2a"
author: "Julianna Calabrese"
date: "12/12/2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
#install.packages("mosaic")
#install.packages("ggplot2")
#install.packages("tidyr")
#install.packages("dplyr")
#install.packages("psych")
#install.packages("nlme")
#install.packages("plyr")
#install.packages("Hmisc")
#install.packages("rmarkdown")
#install.packages("shiny")
#install.packages("yaml")
#install.packages("rapportools")
#install.packages("lavaan")
#install.packages("lme4")
#install.packages("corrr")
#install.packages("corrplot")
#install.packages("reshape2")

library(mosaic)
library(ggplot2)
library(tidyr)
library(dplyr)
library(psych)
library(nlme)
library(plyr)
library(Hmisc)
library(rmarkdown)
library(shiny)
library(yaml)
library(rapportools)
library(lavaan)
library(lme4)
library(corrr)
library(corrplot)
library(reshape2)
```

### Outline/Description

This file will be where all the primary data analysis occurs. First, in a totally separate .rmd file, you'll want to convert cp_whatever to a "long" format, meaning that every time for cortisol will have its own row. This long dataset will also have to include everything else too: gender/demographic data, AUs, CTQ, etc.

Then, you're going to run a model that looks like this...

mod1 <- lm(cortisol~time+time^2+sex+AU1+AU1*time+AU1*time*time^2)

...but it's not going to be a lm() model, it's going to be a multilevel growth curve model, so you'll probably need to use the lme4() package with the lmer() command. This will produce a fixed effects table that represents the parameters of everything that you put in the above model to predict cortisol. Then you need to tell R what your random effects are, which is the intercept and time. 

Then you do something with landmark registration, but that's kind of already done, so you need to ask someone who ask access to that dataset to share it with you.

All the instructions can be found in Lopez-Duran 2014. Do NOT do anything involving AUC!

## Load in data and other logistics

```{r}
cp_long <- read.csv(file="C:/Users/jrcala/Documents/My Research/RStudio/cp_long.csv", header=TRUE, sep=",")
#cp_long <- read.csv(file="/Users/Julianna/Desktop/data/cp_long.csv", header=TRUE, sep=",")
cp_long$X <- NULL
```

## Pre-Analysis Cleaning

```{r}
cp_long$ctqsum <- cp_long$CTQ_Total_Sum
cp_long$emosum <- cp_long$CTQ_EmoAbuse_Sum

cp_long$CTQ_Total_Sum <- NULL
cp_long$CTQ_Total_Mean <- NULL
cp_long$CTQ_EmoAbuse_Sum <- NULL
cp_long$CTQ_EmoAbuse_Mean <- NULL
cp_long$CTQ_PhyAbuse_Sum <- NULL
cp_long$CTQ_PhyAbuse_Mean <- NULL
cp_long$CTQ_SexAbuse_Sum <- NULL
cp_long$CTQ_SexAbuse_Mean <- NULL
```

## Centering

```{r}
hist(cp_long$pain) #Wow, that's terrible
cp_long$painC <- scale(cp_long$pain)
hist(cp_long$painC) #Slightly better, there's an outlier though

hist(cp_long$anger)
cp_long$angerC <- scale(cp_long$anger)
hist(cp_long$angerC)

hist(cp_long$fear)
cp_long$fearC <- scale(cp_long$fear)
hist(cp_long$fear)

hist(cp_long$happiness)
cp_long$happinessC <- scale(cp_long$happiness)
hist(cp_long$happinessC)

hist(cp_long$peaktimenum)
cp_long$peaktimenumC <- scale(cp_long$peaktimenum)
hist(cp_long$peaktimenumC)

hist(cp_long$cortvalue)
cp_long$cortvalueC <- scale(cp_long$cortvalue)
hist(cp_long$cortvalueC)

hist(cp_long$stime) #That looks fine
cp_long$stimeC <- scale(cp_long$stime)
hist(cp_long$stimeC) #It almost looks worse in a way, maybe I won't use it

hist(cp_long$ctqsum)
cp_long$ctqsumC <- scale(cp_long$ctqsum)
hist(cp_long$ctqsumC)

hist(cp_long$emosum)
cp_long$emosumC <- scale(cp_long$emosum)
hist(cp_long$emosumC)

#This is timenum's version of centering
cp_long$timenumC <- 0
cp_long$timenumC[cp_long$timenum==4] <- 1
cp_long$timenumC[cp_long$timenum==5] <- 2
cp_long$timenumC[cp_long$timenum==6] <- 3
cp_long$timenumC[cp_long$timenum==7] <- 4
cp_long$timenumC[cp_long$timenum==8] <- 5
cp_long$timenumC[cp_long$timenum==9] <- 6
cp_long$timenumC[cp_long$timenum==10] <- 7
cp_long$timenumC[cp_long$timenum==11] <- 8
cp_long$timenumC[cp_long$timenum==12] <- 9

cp_long$timenum <- as.factor(cp_long$timenum)
cp_long$timenumC <- as.factor(cp_long$timenumC)
```

## Creating variables: maxtime, timetopeak, timebeforepeak, timeafterpeak

```{r}
cp_long$maxtime <- 0
cp_long$maxtime <- ave(cp_long$stimeC, cp_long$id, FUN = max)
hist(cp_long$maxtime)

cp_long$timetopeak <- 0
cp_long$timetopeak <- (cp_long$peaktimenumC - cp_long$maxtime) * -1
hist(cp_long$timetopeak)

cp_long$timebeforepeak <- 0
cp_long$timebeforepeak <- ifelse(cp_long$timetopeak < 0, cp_long$timetopeak, 0)
#If timetopeak < 0, then timebeforepeak = timetopeak
#If timetopeak > 0, then timebeforepeak = 0
hist(cp_long$timebeforepeak)

cp_long$timeafterpeak <- 0
cp_long$timeafterpeak <- ifelse(cp_long$timetopeak > 0, cp_long$timetopeak, 0)
#If timetopeak > 0, then timeafterpeak = timetopeak
#If timetopeak < 0, then timeafterpeak = 0
hist(cp_long$timeafterpeak)
```

## Creating variables: maxgrouptime, timebeforegrouppeak, timeaftergrouppeak

```{r}
#Uhhhh... I'll do that later. I'm not 100% sure what I should use as the "group" anyway. 
#Maybe I don't even need to do this step. 
```

## Replicating that plot from Lopez-Duran 2014

```{r}
test.plot <- aggregate( cortvalue ~ timenumC, cp_long, mean )

plot(test.plot, lwd=2, type="o", xlab="Time", ylab="Cortisol", main="Mean Cortisol Over Time")

ggplot(cp_long, aes(timenum, cortvalue, group=factor(id))) + geom_line(aes(color=factor(timenum))) + theme(legend.position = "none") + ggtitle("Cortisol Line Graph")

ggplot(cp_long, aes(timenum, cortvalue, group=factor(id))) + geom_jitter(aes(color=factor(timenum))) + theme(legend.position = "none") + ggtitle("Cortisol Dot Plot")
```

## Correlation Matrix of relevant variables

```{r}
matrix_vars <- cp_long[c("cortvalue","stimeC","timenumC","painC","gender","ctqsumC")]

matrix_vars <- data.matrix(matrix_vars)

matrix1 <- cor(matrix_vars, use = "complete.obs")

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

corrplot(matrix1, method = "color", col = col(200),
         type = "upper", order = "hclust", number.cex = .7,
         addCoef.col = "black", # Add coefficient of correlation
         tl.col = "black", tl.srt = 90, # Text label color and rotation
         # Combine with significance
         #sig.level = 0.05, insig = "blank", 
         # hide correlation coefficient on the principal diagonal (or not)
         diag = TRUE, title = "Correlation Matrix", mar=c(0,0,1,0))
```

# Aim 2a

# Using lmer() with the lme4 package

https://ourcodingclub.github.io/2017/03/15/mixed-models.html

1. Check distribution of explanatory variable(s).
2. Standardize explanatory variable(s).
3. Make basic lm() model.
4. Check assumptions for the basic lm() model.
5. Run more analyses if assumptions have been violated.
6. Modify the basic lm() model.
7. Fit your first lmer() model.
8. Check assumptions for the first lmer() model.
9. [Do something re: crossed vs. nested effects, but I don't think this applies here.]
10. Make it all look pretty in tables and graphs.

## Testing out the big model with lm()

```{r}
original <- lm(cortvalue~stime+stime^2+gender+painC+painC*stime+painC*stime*stime^2, data=cp_long)
summary(original)
#This says that everything is significant: time, gender, pain, and interaction between time and pain except the Intercept.

original2 <- lm(cortvalue~stimeC+stimeC^2+gender+painC+painC*stimeC+painC*stimeC*stimeC^2, data=cp_long)
summary(original2)
#Okay, now pain isn't significant, huh. And now the intercept is significant. This is probably the correct model.
```

## Checking distributions

```{r}
hist(cp_long$cortvalue)
hist(cp_long$stimeC)
hist(cp_long$painC)
```

## Basic lm() models

```{r}
basic1 <- lm(cortvalue ~ stimeC, data = cp_long)
summary(basic1) #Intercept and stimeC are significant

basic2 <- lm(cortvalue ~ gender, data = cp_long)
summary(basic2) #Intercept and gender are significant

basic3 <- lm(cortvalue ~ painC, data = cp_long)
summary(basic3) #Intercept is significant but painC is not

basic4 <- lm(cortvalue ~ ctqsumC, data = cp_long)
summary(basic4) #Intercept and CTQ are significant
```

## Checking assumptions

```{r}
plot(basic1, which = 1) #Linearity
plot(basic1, which = 2) #Normality
plot(basic1, which = 3) #Equality of variance
plot(basic1, which = 4) #Leverage / Identifies outliers

plot(basic1)
plot(basic2)
plot(basic3)
plot(basic4)
```

## Modified lm() models

```{r}
modified1 <- lm(cortvalue ~ stimeC + gender, data = cp_long)
summary(modified1) #All are significant
plot(modified1)

modified2 <- lm(cortvalue ~ stimeC + painC, data = cp_long)
summary(modified2) #Only Intercept and stimeC are significant
plot(modified2)

modified3 <- lm(cortvalue ~ stimeC + painC + gender, data = cp_long)
summary(modified3) #Intercept, stimeC, and gender are significant
plot(modified3)

modified4 <- lm(cortvalue ~ stimeC + ctqsumC + gender, data = cp_long)
summary(modified4) #All are significant
plot(modified4)

modified5 <- lm(cortvalue ~ timenumC + ctqsumC + gender, data = cp_long)
summary(modified5) #All are significant
plot(modified5)
```

## lmer() model

```{r}
#mixed.lmer <- lmer(testScore ~ bodyLength2 + (1|mountainRange), data = dragons)
#summary(mixed.lmer)
#mountainRange is the random effect, bodyLength2 is fixed
#See that fun little 1? That's the intercept!

#Mixed effects models are supposed to have categorical variables... (and gender doesn't count here!)

#Models that use stimeC

lmer1 <- lmer(cortvalue ~ painC + (1|stimeC), data = cp_long)
summary(lmer1)

lmer2 <- lmer(cortvalue ~ gender + (1|stimeC), data = cp_long)
summary(lmer2)

lmer3 <- lmer(cortvalue ~ ctqsumC + (1|stimeC), data = cp_long)
summary(lmer3)

lmer4 <- lmer(cortvalue ~ painC + gender + ctqsumC + (1|stimeC), data = cp_long)
summary(lmer4)

#Models that use timenumC

lmer5 <- lmer(cortvalue ~ painC + (1|timenumC), data = cp_long)
summary(lmer5)

lmer6 <- lmer(cortvalue ~ gender + (1|timenumC), data = cp_long)
summary(lmer6)

lmer7 <- lmer(cortvalue ~ ctqsumC + (1|timenumC), data = cp_long)
summary(lmer7)

lmer8 <- lmer(cortvalue ~ painC + gender + ctqsumC + (1|timenumC), data = cp_long)
summary(lmer8)
```

Let's see if either of those lmer() models worked. Probably not.

```{r}
plot(lmer1)
plot(lmer2)
plot(lmer3)
plot(lmer4)

plot(lmer5)
plot(lmer6)
plot(lmer7)
plot(lmer8)
```

```{r}
qqnorm(resid(lmer1)) + qqline(resid(lmer1))
qqnorm(resid(lmer2)) + qqline(resid(lmer2))
qqnorm(resid(lmer3)) + qqline(resid(lmer3))
qqnorm(resid(lmer4)) + qqline(resid(lmer4))
#Gives warning but plots anyway
```

For "lmer4"...

stimeC variance: 0.04193
Residual variance: 1.02347
Total variance: 0.04193 + 1.02347 = 1.0654
Variance explained by stimeC = 0.04193/1.0654 = 0.03936
Cool... so stimeC explains 3% of the variance in lmer4. 

Same thing if timenumC replaces stimeC (2.8%).

I am still unsure whether I should stimeC or timenumC. 

# Using lme() with the nlme package

```{r}
#The default is method="REML" anyway
lme1 <- lme(cortvalue ~ painC,
            data = cp_long,
            random=~1|stimeC,
            method="REML")
summary(lme1)

lme2 <- lme(cortvalue ~ gender,
            data = cp_long,
            random=~1|stimeC,
            method="REML")
summary(lme2)

lme3 <- lme(cortvalue ~ ctqsumC,
            data = cp_long,
            random=~1|stimeC,
            method="REML")
summary(lme3)

lme4 <- lme(cortvalue ~ painC + gender + ctqsumC,
            data = cp_long,
            random=~1|stimeC,
            method="REML")
summary(lme4)
```

## lme() plots

```{r}
plot(lme1)
plot(lme2)
plot(lme3)
plot(lme4)
```

```{r}
qqnorm(resid(lme1)) + qqline(resid(lme1))
qqnorm(resid(lme2)) + qqline(resid(lme2))
qqnorm(resid(lme3)) + qqline(resid(lme3))
qqnorm(resid(lme4)) + qqline(resid(lme4))
#Gives warning but plots anyway
```

# Side by side comparison of lme() and lmer()

```{r}
summary(lmer4)
summary(lme4)

coef(summary(lmer4))
coef(summary(lme4))

#They look basically the same, the only difference is that lmer() doesn't provide p-values as designed by the package-maker
```

## Moderation with lme() WORK IN PROGRESS!!!!

```{r}
lmemod2 <- lme(cortvalue ~ painC + ctqsumC + gender + painC*ctqsumC, 
              data=cp_long,
              random=~1|stimeC)
summary(lmemod2)
```

```{r}
lmemod3 <- lme(cortvalue ~ painC + ctqsumC + painC*ctqsumC, 
              data=cp_long,
              random=~1|stimeC)
summary(lmemod3)
```

```{r}
lmemod4 <- lme(cortvalue ~ painC + ctqsumC + gender*ctqsumC, 
              data=cp_long,
              random=~1|stimeC)
summary(lmemod4)
```

## Writing out the new cp_long

```{r}
#write.csv(cp_long, file="/Users/Julianna/Desktop/data/cp_long_aim2a.csv")
write.csv(cp_long, file="C:/Users/jrcala/Documents/My Research/RStudio/cp_long_aim2a.csv")
```

